{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Aloe Documentation Center","text":"<p>Welcome to the Aloe Documentation Center. Here, you will find all the necessary resources and documentation to work with our open-source tools or discover awesome open-source projects.</p>"},{"location":"#current-status","title":"Current status","text":"<p>This website is under active development.</p>"},{"location":"#contact-us","title":"Contact us","text":"<p>Please visit our Github page to learn more about Aloe.</p>"},{"location":"lombrigo/","title":"Lombrigo","text":"<p>Welcome to Lombrigo documentation center. You will find here all documentation and necessary resources to use the Lombrigo CLI.</p>"},{"location":"lombrigo/#what-is-lombrigo","title":"What is Lombrigo","text":"<p>Lombrigo is an open source tool to build scalable, extensible and production ready back-end web server in Golang. Lombrigo fasten the development of web server by generating boiler plate code. It is based on a mature API architecture that is already used in production for some projects.</p> <p>By using Lombrigo, you speed up your development time while remaining in total control of your code. Lombrigo is not meant to do the work for you; it is here to standardize API architecture and improve efficiency.</p>"},{"location":"lombrigo/#explore","title":"Explore","text":"<ul> <li>Learn the API Architecture</li> <li>Getting started with Lombrigo</li> </ul>"},{"location":"lombrigo/concepts/","title":"Concepts","text":"<p>This section of the documentation describes the architecture of the API. You will find guidelines and definitions about each package, in addition of good code examples.</p> <p>Navigate:</p> <ul> <li>routers</li> <li>controllers</li> <li>repositories</li> </ul>"},{"location":"lombrigo/concepts/controllers/","title":"Controllers","text":"<p>A <code>controller</code> is an entity that is responsible to execute the business logic of the endpoint. It is here that any complex / business domain specific process are done.</p> <p>Controllers are called by <code>routers</code> which means that the incoming data has already been validated.</p>"},{"location":"lombrigo/concepts/controllers/#working-with-controllers","title":"Working with controllers","text":"<p>To create a working controller we need two things:</p> <ul> <li>Defining the controller object and its methods</li> <li>Creating its configuration and its factory</li> </ul>"},{"location":"lombrigo/concepts/controllers/#defining-the-controller-object","title":"Defining the controller object","text":"<p>Controllers are located in the <code>internal/controllers</code> package. Here is an example controller named <code>frog_controller.go</code>.</p> <pre><code>package controllers\n\nimport (\n    \"context\"\n    \"fmt\"\n\n    model \"github.com/Aloe-Corporation/frog-api/pkg/structs\"\n\n    \"github.com/Aloe-Corporation/frog-api/internal/repositories\"\n)\n\nvar (\n    _ IFrogController = (*FrogController)(nil)\n)\n\n// IFrogController is an interface for FrogController and FrogControllerMocking.\ntype IFrogController interface {\n    Get(ctx context.Context) (*model.FrogPublicDTO, error)\n}\n\n// FrogControllerConf is a configuration structure for FrogController.\ntype FrogControllerConf struct {\n    FrogDAO repositories.DAOFactoryOptions `mapstructure:\"frog_dao\"`\n}\n\n// FrogController is an controllers to manage business logic of Frog.\ntype FrogController struct {\n    daoFrog repositories.IFrogDAO\n}\n\nfunc (c *FrogController) Get(ctx context.Context) (*model.FrogPublicDTO, error) {\n    frog, err := c.daoFrog.ReadByUUID(ctx)\n    if err != nil {\n        return nil, fmt.Errorf(\"fail to get frog: %w\", err)\n    }\n\n    return model.FactoryFrogPublicDTO(frog), nil\n}\n\n// factoryFrogController is use to build an FrogController according to the conf.\nfunc factoryFrogController(c FrogControllerConf) (*FrogController, error) {\n    log.Info(\"loading FrogDAO...\")\n    daoFrog, err := repositories.ProxyFactoryFrogDAO(c.FrogDAO)\n    if err != nil {\n        return nil, fmt.Errorf(\"fail to load FrogDAO: %w\", err)\n    }\n    log.Info(\"FrogDAO loaded\")\n\n    controllers := &amp;FrogController{\n        daoFrog: daoFrog,\n    }\n    return controllers, nil\n}\n\n</code></pre> <p>This <code>FrogController</code> defines an interface <code>IFrogController</code> that defines its public function. Callers are using the interface rather than the implementation.  </p> <p>The <code>FrogControllerConf</code> holds the configuration for the controller, here it contains the configuration to instanciates a `FrogDAO``</p> <p>Finally we can see that <code>FrogController</code> struct contains an <code>IFrogDAO</code> which is the object responsible to retrieve the data from our datasource. See the repositories package for more details.</p> <p>Our controller is really simple in this example, it only contains a <code>FrogController.Get</code> method that asks to the  <code>IFrogDAO</code> to retrieve a frog by its UUID, then it returns the public representation of the <code>Frog</code> object to the caller. See working with DTO for more details.</p> <p>To create a <code>FrogController</code> instance, there is  <code>factoryFrogController</code> function that do the necessary to create it.</p> <p>Our controller object is ready, now we have to initialize it and make it usable.</p>"},{"location":"lombrigo/concepts/controllers/#initialization-of-the-controller","title":"Initialization of the controller","text":"<p>The <code>\u00ecnternal/controllers/controller.go</code> file is responsible to initialize all the controllers.</p> <pre><code>package controllers\n\nimport (\n    \"fmt\"\n\n    \"github.com/Aloe-Corporation/logs\"\n)\n\nvar (\n    log = logs.Get()\n    // Config of the controllers package\n    Config Conf\n\n    // Add your intance below\n\n    // FrogInstance is an instance of IFrogController.\n    FrogInstance IFrogController\n)\n\n// Conf for the controllers package\ntype Conf struct {\n    FrogController FrogControllerConf `mapstructure:\"frog_controller\"`\n}\n\n// Init the controllerss\nfunc Init() error {\n    var err error\n\n    log.Info(\"init FrogController...\")\n    FrogInstance, err = factoryFrogController(Config.FrogController)\n    if err != nil {\n        return fmt.Errorf(\"fail to build FrogController: %w\", err)\n    }\n    log.Info(\"FrogController is ready to use\")\n\n    log.Info(\"controllers package ready\")\n    return err\n}\n\n</code></pre> <p>The <code>controller.go</code> file defines the configuration of the <code>controllers</code> package through the <code>Conf</code> structure. It basically gathers the configuration of each controller.</p> <p>It defines an <code>Init()</code> method that instanciates every controllers by calling their <code>factory</code>. Controllers will be available through a global instance. In the example above the <code>FrogController</code> is available through the <code>FrogInstance</code> variable.</p> <p>Our controller is ready, we can now creates dao in ours repositories</p>"},{"location":"lombrigo/concepts/repositories/","title":"Repositories","text":"<p>The <code>repositories</code> package gathers the entities that are responsible for interacting with data sources. These entities are called <code>DAO</code> (Data Access Object). They are a high-level abstraction of one or more specific data sources. The abstraction of the target data source allows the caller (generally a <code>controller</code>) to be fully unbound from a data source implementation. This permits high flexibility and extensibility.</p>"},{"location":"lombrigo/concepts/repositories/#understanding-dao","title":"Understanding DAO","text":"<p>A <code>DAO</code> is not an abstraction of a data source; it is defined to retrieve an entity. Different implementations will then retrieve the needed data using data source connectors.</p> <p>Here is a scheme that explains it:</p> <p></p> <p>For example, if our API needs to manipulate a <code>Car</code> object, we would define a <code>ICarDAO</code> that is the  abstraction, and we would implement a <code>MySQLCarDAO</code> as the implementation of <code>ICarDAO</code> to manipulate a <code>Car</code> object stored in a MySQL database.</p>"},{"location":"lombrigo/concepts/repositories/#working-with-dao","title":"Working with DAO","text":"<p>To create a working <code>DAO</code>, we need a few things:</p> <ul> <li>Defining the DAO interface.</li> <li>Creating one or more implementation(s) for a specific data source.</li> </ul>"},{"location":"lombrigo/concepts/repositories/#defining-the-dao-interface","title":"Defining the DAO interface","text":""},{"location":"lombrigo/concepts/repositories/#components","title":"Components","text":"<p>DAO Interface</p> <p>The <code>&lt;Entity&gt;DAO</code> interface serves as a contract for managing data access operations related to a specific model. The interface declares operations on model entities. Implementations of this interface should provide functionality tailored to the characteristics of the specific model.</p> <p>ProxyFactory&lt;Entity&gt;DAO</p> <p>The <code>ProxyFactory&lt;Entity&gt;DAO</code> function acts as a proxy for creating and retrieving IDAO instances. It checks if a specific type and connector combination already exists in the registry (mapDAO). If found, it returns the existing instance; otherwise, it delegates the creation to the <code>Factory&lt;Entity&gt;DAO</code> function. The newly created <code>I&lt;Entity&gt;DAO</code> instance is then saved in the registry for future use. <p>Factory&lt;Entity&gt;DAO</p> <p>The <code>Factory&lt;Entity&gt;DAO</code> function is responsible for creating a new <code>I&lt;Entity&gt;DAO</code> instance based on the provided <code>DAOFactoryOptions</code>. It uses a switch statement to determine the <code>DAO</code> type and calls the corresponding factory function for that type. If the specified <code>DAO</code> type is not recognized, it returns a <code>DAOTypeNotFoundError</code>. The created <code>I&lt;Entity&gt;DAO</code> instance is returned if successful.</p> <p>See configuring the API for more details.</p>"},{"location":"lombrigo/concepts/repositories/#example","title":"Example","text":"<p>Here is an example for an <code>IFrogDAO</code>:</p> <pre><code>package repositories\n\nimport (\n    \"context\"\n    \"fmt\"\n\n    model \"github.com/Aloe-Corporation/frog-api/pkg/structs\"\n)\n\n// mapFrogDAO is used by ProxyFactoryFrogDAO to store FrogDAO.\nvar mapFrogDAO = make(map[string]map[string]IFrogDAO)\n\n// IFrogDAO is a DAO interface to manage Frog.\ntype IFrogDAO interface {\n    ReadByUUID(ctx context.Context) (*model.Frog, error)\n}\n\n// ProxyFactoryFrogDAO uses FactoryFrogDAO if the FrogDAO don't exist, and returns FrogDAO.\nfunc ProxyFactoryFrogDAO(opt DAOFactoryOptions) (IFrogDAO, error) {\n    // Test if exist\n    mapConnector, mapExist := mapFrogDAO[opt.Type]\n    if mapExist {\n        daoFrog, present := mapConnector[opt.Connector]\n        if present {\n            return daoFrog, nil\n        }\n    }\n\n    // Build new FrogDAO\n    daoFrog, err := FactoryFrogDAO(opt)\n    if err != nil {\n        return nil, fmt.Errorf(\"fail to build new FrogDAO: %w\", err)\n    }\n\n    // Save new FrogDAO\n    if !mapExist {\n        mapFrogDAO[opt.Type] = make(map[string]IFrogDAO)\n    }\n    mapFrogDAO[opt.Type][opt.Connector] = daoFrog\n\n    return daoFrog, nil\n}\n\n// FactoryFrogDAO builds a new FrogDAO according to the typename.\nfunc FactoryFrogDAO(opt DAOFactoryOptions) (IFrogDAO, error) {\n    var dao IFrogDAO\n    var err error\n\n    switch opt.Type {\n    case TypeFrogMongoDAO:\n        dao, err = factoryFrogMongoDAO(opt)\n    default:\n        return nil, &amp;DAOTypeNotFoundError{Type: opt.Type}\n    }\n\n    if err != nil {\n        return nil, fmt.Errorf(\"fail to build %v: %w\", opt.Type, err)\n    }\n\n    return dao, nil\n} \n</code></pre>"},{"location":"lombrigo/concepts/repositories/#defining-dao-implementations","title":"Defining DAO implementations","text":""},{"location":"lombrigo/concepts/repositories/#components_1","title":"Components","text":"<p>DAO identifier</p> <p>Each DAO implementation must define an identifier to identify the implementation. This identifier will be used to instantiate the DAO in the call of the DAO interface proxy factory during API initialization.</p> <p>DAO implementation structure</p> <p>The implementation of the <code>DAO</code> is represented as a struct that holds a <code>connector</code> to the data source. The <code>connector</code> is defined in the connectors package. Every connectors are defined in the connectors package to lighten the repositories code and to improve modularity.</p> <p>The implementation must contain a <code>connectorName</code> field to identify the correct <code>connector</code> when initializing the <code>DAO</code>.</p> <p>DAO methods</p> <p>The implementation must implement all the methods defined by the <code>DAO interface</code> to respect the contract.</p> <p>The implementation can also contain additional private methods to facilitate some processes.</p> <p>Private factory</p> <p>Each implementation must define a private factory that will be called by its corresponding DAO interface proxy factory.</p> <p>See configuring the API for more details.</p>"},{"location":"lombrigo/concepts/repositories/#example_1","title":"Example","text":"<p>Here is an example with a <code>FrogMongoDAO</code> that implements the <code>IFrogDAO</code>:</p> <pre><code>package repositories\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"github.com/Aloe-Corporation/frog-api/internal/connectors\"\n    model \"github.com/Aloe-Corporation/frog-api/pkg/structs\"\n    \"github.com/Aloe-Corporation/mongodb\"\n    \"github.com/google/uuid\"\n)\n\nconst (\n    // TypeFrogMongoDAO is an identifier to build FrogMongoDAO.\n    TypeFrogMongoDAO = \"FrogMongoDAO\"\n)\n\nvar _ IFrogDAO = (*FrogMongoDAO)(nil)\n\n// FrogMongoDAO is a FrogDAO with MySQL connector.\ntype FrogMongoDAO struct {\n    connector     *mongodb.Connector\n    connectorName string\n}\n\n\nfunc (dao *FrogMongoDAO) ReadByUUID(ctx context.Context) (*model.Frog, error) {\n    // mongo db specific code\n    return nil, nil\n}\n\n\n// factoryFrogMongoDAO build FrogMongoDAO.\nfunc factoryFrogMongoDAO(opt DAOFactoryOptions) (*FrogMongoDAO, error) {\n    connector, err := connectors.GetConnectorMongo(opt.Connector)\n    if err != nil {\n        return nil, fmt.Errorf(\"fail to get connector: %w\", err)\n    }\n\n    return &amp;FrogMongoDAO{\n        connector:     connector,\n        connectorName: opt.Connector,\n    }, nil\n}\n</code></pre>"},{"location":"lombrigo/concepts/routers/","title":"Routers","text":"<p>A <code>router</code> is an entity that is responsible to handle incoming request, validate it and transmit it to the appropriate controller.</p> <p>Our API is extensible and you can add whatever type of router that you want. As a base router, we will see how to create a router based on the gin gin web framework.</p> <p>NOTE: all external dependencies are referenced in the  dependencies reference page.</p>"},{"location":"lombrigo/concepts/routers/#working-with-gin-routers","title":"Working with gin routers","text":"<p>To create a working gin router we need two things:</p> <ul> <li>We need to defines our endpoints</li> <li>We need to defines router handlers that will be called when a client make a request to our API</li> </ul>"},{"location":"lombrigo/concepts/routers/#defining-endpoints","title":"Defining endpoints","text":"<p>We need to defines our endpoints in the <code>internal/ginrouters/router.go</code> file. </p> <p>Here is an example:</p> <pre><code>package ginrouters\n\nimport (\n    \"net/http\"\n    \"time\"\n\n    \"github.com/Aloe-Corporation/logs\"\n    \"github.com/Aloe-Corporation/cors\"\n    ginzap \"github.com/gin-contrib/zap\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/go-playground/validator/v10\"\n)\n\nvar (\n    log = logs.Get()\n    // Config of the routers package.\n    Config Conf\n    // Router of the API.\n    Router *gin.Engine\n\n    // Validate singleton, used by all routers to validate request body data.\n    ValidateInstance *validator.Validate\n)\n\ntype HomeMessage struct {\n    Service   string `json:\"service\"`\n    Copyright string `json:\"copyright\"`\n}\n\n// Conf for the routers package.\ntype Conf struct {\n    GinMode         string `mapstructure:\"gin_mode\"`\n    Addr            string `mapstructure:\"addr\"`\n    Port            int    `mapstructure:\"port\"`\n    ShutdownTimeout int    `mapstructure:\"shutdown_timeout\"`\n}\n\n// Init create a gin.Engine and define multiplexer of the Engine.\nfunc Init() {\n    ValidateInstance = validator.New()\n\n    log.Info(\"init ginrouters package...\")\n    gin.SetMode(Config.GinMode)\n\n    // set up the routing.\n    log.Info(\"instantiate gin engine...\")\n    Router = gin.New()\n    log.Info(\"gin engine instantiate\")\n\n    // Middleware.\n    log.Info(\"load middlewares...\")\n    Router.Use(ginzap.RecoveryWithZap(log, true))\n    Router.Use(ginzap.Ginzap(log, time.RFC3339, true))\n    Router.Use(cors.Middleware(cors.DefaultConf()))\n    log.Info(\"middlewares loaded\")\n\n    // Add your handler below this log.\n    log.Info(\"load handlers...\")\n\n    Router.Group(\"/frog\").GET(\"/:frog_uuid\", GetInstanceFrogRouter().Get)\n\n    // Specific handler\n    log.Info(\"load specific handlers...\")\n    Router.GET(\"/\", func(c *gin.Context) {\n        c.JSON(http.StatusOK, HomeMessage{\n            Service:   \"Frog API\",\n            Copyright: \"Aloe corporation\",\n        })\n    })\n\n    Router.NoRoute(func(c *gin.Context) {\n        c.JSON(http.StatusNotFound, \"Not Found\")\n    })\n\n    Router.NoMethod(func(c *gin.Context) {\n        c.JSON(http.StatusMethodNotAllowed, \"Not Allowed\")\n    })\n    log.Info(\"specific handlers loaded\")\n\n    log.Info(\"handlers loaded\")\n\n    log.Info(\"ginrouters package ready\")\n}\n</code></pre> <p>The file defines the Init function that does the following things:</p> <ul> <li>A <code>*gin.Engine</code> is created</li> <li>The <code>/frog/:frog_uuid</code> endpoint is defined and we've attached the <code>GetInstanceFrogRouter().Get</code> to it (we will see that later)</li> <li>We've defined some boiler plates code the as the '/' endpoint</li> <li>We've defined specific behaviours when the incoming request is not handled by our API or when the method is unknown</li> </ul> <p>In addition to that you can see that we've declared <code>*validator.Validate</code> instance. This is used to validate request body thanks to tags on target structs. To see more about data validation see the data validation section.</p> <p>The <code>Init()</code> function has to be called in the <code>main.go</code> of our API. See creating the main file section for more details.</p> <p>The configuration of the router package is held by the <code>Conf</code> structure. See configuring the API for more details.</p> <p>Now that our <code>router.go</code> is defined, we can create our router handle for our <code>frog</code> endpoint.</p>"},{"location":"lombrigo/concepts/routers/#creating-router-handlers","title":"Creating router handlers","text":"<p>Router handlers are responsible to validate the incoming data from the request and transmit it to the good controller. A router handler file defines several handlers that are responsible to manage one resource or logic domain.</p> <p>The <code>internal/ginrouters/frog_router.go</code> file:</p> <pre><code>package ginrouters\n\nimport (\n    \"net/http\"\n    \"sync\"\n    model \"github.com/Aloe-Corporation/frog-api/pkg/structs\"\n    \"context\"\n    \"github.com/google/uuid\"\n    ginparamsmapper \"gitlab.com/Zandraz/gin-params-mapper\"\n    \"github.com/Aloe-Corporation/frog-api/internal/controllers\"\n    \"github.com/mitchellh/mapstructure\"\n    \"github.com/gin-gonic/gin\"\n    \"go.uber.org/zap\"\n)\n\nvar (\n    onceInitFrogRouter sync.Once\n    // singletonFrogRouter is a singleton instance of FrogRouter.\n    singletonFrogRouter *FrogRouter\n)\n\n// FrogRouter groups a set of handlers to manage entrypoints of Frog.\ntype FrogRouter struct {\n    ctlFrog controller.IFrogController\n}\n\nfunc (r * FrogRouter) Get(c *gin.Context) {\n    var frogUUID uuid.UUID\n    if err := ginparamsmapper.GetPathParamFromContext(\"frog_uuid\", c, &amp;frogUUID); err != nil {\n        log.Error(\"FrogRouter.Get fail to get path param frog_uuid: \", zap.Error(err))\n        c.JSON(http.StatusBadRequest, \"Bad Request\")\n        return\n    }\n\n    ctx := context.WithValue(c, \"frog_uuid\", &amp;frogUUID)\n\n    frog, err := r.ctlFrog.Get(ctx)\n    if err != nil {\n        log.Error(\"FrogController.GetByUUID fail\",\n            zap.Any(\"frog_uuid\", frogUUID),\n            zap.Error(err),\n        )\n        c.JSON(http.StatusBadRequest, \"Bad Request\")\n        return\n    }\n\n    c.JSON(http.StatusOK, frog)\n}\n\n// GetInstanceFrogRouter get singleton instance of FrogRouter.\nfunc GetInstanceFrogRouter() *FrogRouter {\n    if singletonFrogRouter == nil {\n        onceInitFrogRouter.Do(\n            func() {\n                singletonFrogRouter = &amp;FrogRouter{\n                    ctlFrog: controller.FrogInstance,\n                }\n            },\n        )\n    }\n\n    return singletonFrogRouter\n}\n\n</code></pre> <p>Our frog router handler is represented as a struct that defines methods and that contains a/some <code>controllers</code> interfaces.</p> <p>Each method is an handler, in our example we are defining a <code>Get(c *gin.Context)</code> handler that retrieves the <code>frog_uuid</code> path parameter and awaits that the parameter is an <code>uuid</code>. Then it creates a context to store the validated parameter and transmit it to the controller. If there is no error, the router responds with the found frog.</p> <p>Each router handler defines a <code>singleton</code>. This allows to minify the instantiation code in <code>router.go</code>.</p> <p>At this point, the router implementation is done. We will now have to create controllers.</p>"},{"location":"lombrigo/dependencies/","title":"Dependencies reference","text":"<p>This file list all external dependencies that we use to create API.</p> Dependency Purpose gin-params-mapper Easily parse gin request parameters mapstructure Use to ease structures deconstruction and validation zap Blazing fast, structured, leveled logging in Go cors Easily handle cors in Gin API"},{"location":"lombrigo/packages/","title":"Structure and packages","text":"<p>Learn the structure of our base api and how each packages interact with each others.</p>"},{"location":"lombrigo/packages/#folders-layout","title":"Folders layout","text":"<p>The API as the following folder structure:</p> <pre><code>.\n|-- config\n|-- docs\n|-- internal\n    |-- configuration\n    |-- connectors\n    |-- consumers\n    |-- controller\n    |-- ginrouters\n    |-- notifiers\n    |-- producers\n    |-- repositories\n|-- pkg\n    |-- structs\n|-- test\n\n</code></pre> <p>Each packages have their own responsabilities.</p> Package name Responsability <code>config</code> Location to store .yaml configuration files. <code>docs</code> Location to store any documentation. <code>internal</code> All the API intelligence is created under this folder. <code>pkg</code> Publicly available Go objects. <code>test</code> Unit test related file such as test data etc."},{"location":"lombrigo/packages/#the-internal-package","title":"The internal package","text":"<p>The internal package is where the API code is actually developped. It is splitted in different packages that has specific purposes.</p> <p>Please look at this packages diagram to have an overview on how packages interact with each others.</p> <p> </p>"},{"location":"lombrigo/packages/#ginrouters-or-xxxxrouter","title":"ginrouters or  &lt;xxxx&gt;router","text":"<p>The <code>router</code> type packages contains the code that has the responsability to receive the requests made to our API, validate the data and transmit them to the <code>controllers</code> package.</p> <p>It is here for example that we will define our <code>*gin.Router</code> and the associated paths / endpoints that our API declares.</p> <p>See routers concept for more documentation.</p>"},{"location":"lombrigo/packages/#controllers","title":"controllers","text":"<p>The <code>controllers</code> package contains all the business logic of our API. It is responsible to apply the logic and should be the only component that does this.</p> <p>See controllers concept for more documentation.</p>"},{"location":"lombrigo/packages/#repositories","title":"repositories","text":"<p>The <code>repositories</code> is the layer responsible to store / retrieve data from a data source. A data source can be anything that gives or stores data such as a database, an other API, the file system etc.</p> <p>For example, it is here that you would write your SQL queries in the case that your data source in a SQL Database.</p>"},{"location":"lombrigo/packages/#connectors","title":"connectors","text":"<p>The <code>connectors</code> package defines connectors that will be used by the <code>repositories</code> package to reach the target data source.</p> <p>It is here for example that you would init you <code>sql client</code> and connect it to the database.</p>"},{"location":"lombrigo/packages/#consumers","title":"consumers","text":"<p>The <code>consumers</code> package contains go code related to the connection to an <code>event bus</code> or a <code>message queue</code>. More precisly: all the code that allows the API to consume (listen) to events sent by such services.</p> <p>By reacting to an event, the <code>consumers</code> pacakge can call a controller to do related business logic.</p>"},{"location":"lombrigo/packages/#producers","title":"producers","text":"<p>The <code>producers</code> package contains code to produce events and send them to an an <code>event bus</code> or a <code>message queue</code>.</p> <p>Such messages are generally sent after some business logic has been done by one of the controller in the <code>controllers</code> package.</p>"},{"location":"lombrigo/packages/#notifiers","title":"notifiers","text":"<p>Our API is shipped with a built Observer design pattern. This package is optionnal and targetted for advanced use. However, it can be really usefull when your code begin to be more and more voluminous. Indeed this pattern can help to minify links between objects.</p>"},{"location":"lombrigo/packages/#configuration","title":"configuration","text":"<p>As you can see the <code>configuration</code> package is not in the schema above. This package is used to read the configuration and to distribute it to each package. This package is linked to every others.</p>"}]}